// SPDX-License-Identifier: GPL-2.0

// Generated by scripts/atomic/gen-atomic-instrumented.sh
// DO NOT MODIFY THIS FILE DIRECTLY

/*
 * This file provides wrappers with KASAN instrumentation for atomic operations.
 * To use this functionality an arch's atomic.h file needs to define all
 * atomic operations with arch_ prefix (e.g. arch_atomic_read()) and include
 * this file at the end. This file provides atomic_read() that forwards to
 * arch_atomic_read() for actual atomic operation.
 * Note: if an arch atomic operation is implemented by means of other atomic
 * operations (e.g. atomic_read()/atomic_cmpxchg() loop), then it needs to use
 * arch_ variants (i.e. arch_atomic_read()/arch_atomic_cmpxchg()) to avoid
 * double instrumentation.
 */
#ifndef _LINUX_REFCOUNT_H_
#define _LINUX_REFCOUNT_H_
 
	#include <linux/compiler/myos_debug_option.h>

	#include "../lock_ipc_types.h"
	#include "../lock_ipc_api.h"


	#ifdef DEBUG

		extern void
		refcount_set(refcount_t *r, int n);

		extern uint
		refcount_read(const refcount_t *r);

		extern void
		refcount_add(int i, refcount_t *r);
		extern void
		refcount_inc(refcount_t *r);

		extern void
		refcount_sub(int i, refcount_t *r);
		extern void
		refcount_dec(refcount_t *r);

		extern bool
		refcount_sub_and_test(int i, refcount_t *r);
		extern bool
		refcount_dec_and_test(refcount_t *r);

	#endif

	#include "refcount_macro.h"

	#if defined(REFCOUNT_DEFINATION) || !(DEBUG)

		/**
		 * refcount_set - set a refcount's value
		 * @r: the refcount
		 * @n: value to which the refcount will be set
		 */
		PREFIX_STATIC_INLINE
		void
		refcount_set(refcount_t *r, int n) {
			atomic_set(&r->refs, n);
		}


		/**
		 * refcount_read - get a refcount's value
		 * @r: the refcount
		 *
		 * Return: the refcount's value
		 */
		PREFIX_STATIC_INLINE
		uint
		refcount_read(const refcount_t *r) {
			return atomic_read(&r->refs);
		}


		/**
		 * refcount_add - add a value to a refcount
		 * @i: the value to add to the refcount
		 * @r: the refcount
		 *
		 * Similar to atomic_add(), but will saturate at REFCOUNT_SATURATED and WARN.
		 *
		 * Provides no memory ordering, it is assumed the caller has guaranteed the
		 * object memory to be stable (RCU, etc.). It does provide a control dependency
		 * and thereby orders future stores. See the comment on top.
		 *
		 * Use of this function is not recommended for the normal reference counting
		 * use case in which references are taken and released one at a time.  In these
		 * cases, refcount_inc(), or one of its variants, should instead be used to
		 * increment a reference count.
		 */
		PREFIX_STATIC_INLINE
		void
		refcount_add(int i, refcount_t *r) {
			// int old = atomic_fetch_add_relaxed(i, &r->refs);

			// if (oldp)
			// 	*oldp = old;

			// if (unlikely(!old))
			// 	refcount_warn_saturate(r, REFCOUNT_ADD_UAF);
			// else if (unlikely(old < 0 || old + i < 0))
			// 	refcount_warn_saturate(r, REFCOUNT_ADD_OVF);

			atomic_add(i, &r->refs);
		}

		/**
		 * refcount_inc - increment a refcount
		 * @r: the refcount to increment
		 *
		 * Similar to atomic_inc(), but will saturate at REFCOUNT_SATURATED and WARN.
		 *
		 * Provides no memory ordering, it is assumed the caller already has a
		 * reference on the object.
		 *
		 * Will WARN if the refcount is 0, as this represents a possible use-after-free
		 * condition.
		 */
		PREFIX_STATIC_INLINE
		void
		refcount_inc(refcount_t *r) {
			refcount_add(1, r);
		}


		PREFIX_STATIC_INLINE
		void
		refcount_sub(int i, refcount_t *r) {
			atomic_sub(i, &r->refs);
		}

		/**
		 * refcount_dec - decrement a refcount
		 * @r: the refcount
		 *
		 * Similar to atomic_dec(), it will WARN on underflow and fail to decrement
		 * when saturated at REFCOUNT_SATURATED.
		 *
		 * Provides release memory ordering, such that prior loads and stores are done
		 * before.
		 */
		PREFIX_STATIC_INLINE
		void
		refcount_dec(refcount_t *r) {
			refcount_sub(1, r);
		}

		/**
		 * refcount_sub_and_test - subtract from a refcount and test if it is 0
		 * @i: amount to subtract from the refcount
		 * @r: the refcount
		 *
		 * Similar to atomic_dec_and_test(), but it will WARN, return false and
		 * ultimately leak on underflow and will fail to decrement when saturated
		 * at REFCOUNT_SATURATED.
		 *
		 * Provides release memory ordering, such that prior loads and stores are done
		 * before, and provides an acquire ordering on success such that free()
		 * must come after.
		 *
		 * Use of this function is not recommended for the normal reference counting
		 * use case in which references are taken and released one at a time.  In these
		 * cases, refcount_dec(), or one of its variants, should instead be used to
		 * decrement a reference count.
		 *
		 * Return: true if the resulting refcount is 0, false otherwise
		 */
		PREFIX_STATIC_INLINE
		__must_check
		bool
		refcount_sub_and_test(int i, refcount_t *r) {
			return atomic_sub_and_test(i, &r->refs);
		}

		/**
		 * refcount_dec_and_test - decrement a refcount and test if it is 0
		 * @r: the refcount
		 *
		 * Similar to atomic_dec_and_test(), it will WARN on underflow and fail to
		 * decrement when saturated at REFCOUNT_SATURATED.
		 *
		 * Provides release memory ordering, such that prior loads and stores are done
		 * before, and provides an acquire ordering on success such that free()
		 * must come after.
		 *
		 * Return: true if the resulting refcount is 0, false otherwise
		 */
		PREFIX_STATIC_INLINE
		__must_check
		bool
		refcount_dec_and_test(refcount_t *r) {
			return refcount_sub_and_test(1, r);
		}

	#endif /* !DEBUG */

#endif /* _LINUX_REFCOUNT_H_ */